<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Modern Gesture Particles</title>
    <style>
        body { margin: 0; background: #000; overflow: hidden; font-family: 'Inter', sans-serif; }
        #webcam { position: fixed; bottom: 20px; left: 20px; width: 140px; border-radius: 12px; transform: scaleX(-1); border: 1px solid rgba(255,255,255,0.2); z-index: 10; }
        #ui-overlay { position: fixed; top: 20px; right: 20px; z-index: 100; color: white; text-align: right; }
        .btn { background: rgba(255,255,255,0.15); border: 1px solid rgba(255,255,255,0.2); color: white; padding: 10px 20px; border-radius: 8px; cursor: pointer; backdrop-filter: blur(10px); transition: 0.3s; }
        .btn:hover { background: rgba(255,255,255,0.3); }
        #status { position: fixed; width: 100%; text-align: center; top: 50%; color: rgba(255,255,255,0.5); font-weight: 200; letter-spacing: 2px; }
    </style>
</head>
<body>
    <div id="status">INITIALIZING AI SYSTEM...</div>
    <video id="webcam" autoplay playsinline></video>
    <div id="ui-overlay">
        <button class="btn" id="fs-btn">FULLSCREEN</button>
        <button class="btn" id="text-btn" style="margin-left:8px">I LOVE U</button>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

    <script>
        // --- SCENE SETUP ---
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // --- HIGH-FIDELITY PARTICLES ---
        // Device-aware particle count (keeps performance reasonable on lower-end devices)
        const maxCount = 20000;
        const count = Math.min(maxCount, Math.max(8000, Math.floor(12000 / (window.devicePixelRatio || 1))));
        console.log('particle count', count);

        const geometry = new THREE.BufferGeometry();
        const positions = new Float32Array(count * 3);
        const velocities = new Float32Array(count * 3);
        const sizes = new Float32Array(count);
        const randoms = new Float32Array(count);

        for(let i=0; i<count; i++) {
            positions[i*3] = (Math.random() - 0.5) * 10;
            positions[i*3+1] = (Math.random() - 0.5) * 10;
            positions[i*3+2] = (Math.random() - 0.5) * 10;
            velocities[i*3] = (Math.random() - 0.5) * 0.01;
            velocities[i*3+1] = (Math.random() - 0.5) * 0.01;
            velocities[i*3+2] = (Math.random() - 0.5) * 0.01;
            sizes[i] = Math.random() * 0.9 + 0.1;
            randoms[i] = Math.random();
        }

        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
        geometry.setAttribute('random', new THREE.BufferAttribute(randoms, 1));

        // Create a soft radial sprite (fuzzy dust look)
        function createSprite(){
            const size = 128;
            const canvas = document.createElement('canvas');
            canvas.width = canvas.height = size;
            const ctx = canvas.getContext('2d');
            const grad = ctx.createRadialGradient(size/2,size/2,0,size/2,size/2,size/2);
            grad.addColorStop(0, 'rgba(255,255,255,1)');
            grad.addColorStop(0.3, 'rgba(255,255,255,0.7)');
            grad.addColorStop(1, 'rgba(255,255,255,0)');
            ctx.fillStyle = grad; ctx.fillRect(0,0,size,size);
            return new THREE.CanvasTexture(canvas);
        }
        const sprite = createSprite();

        const material = new THREE.ShaderMaterial({
            uniforms: {
                uTime: { value: 0 },
                uExp: { value: 0 },
                uColor: { value: new THREE.Color("#00f2ff") },
                uSprite: { value: sprite }
            },
            vertexShader: `
                uniform float uTime;
                uniform float uExp;
                attribute float size;
                attribute float random;
                varying float vOpacity;
                varying float vRandom;
                void main() {
                    vec3 pos = position;
                    float dist = length(pos);
                    pos += normalize(pos) * (uExp * 5.0 * random);
                    pos.y += sin(uTime * 0.5 + pos.x * (1.0 + random)) * 0.3;
                    pos.z += cos(uTime * 0.3 + pos.y * (1.0 + random)) * 0.3;

                    vRandom = random;
                    vOpacity = 1.0 - (uExp * 0.5) * random;

                    vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
                    float psize = size * (14.0 * (1.0 + uExp)) * (300.0 / -mvPosition.z);
                    gl_PointSize = clamp(psize, 1.0, 80.0);
                    gl_Position = projectionMatrix * mvPosition;
                }
            `,
            fragmentShader: `
                uniform sampler2D uSprite;
                uniform vec3 uColor;
                varying float vOpacity;
                varying float vRandom;
                void main(){
                    vec4 tex = texture2D(uSprite, gl_PointCoord);
                    float alpha = tex.a * vOpacity;
                    // smoother falloff and more reliable visibility
                    float a = smoothstep(0.0, 0.7, alpha);
                    if(a < 0.005) discard;
                    vec3 color = uColor * a * tex.rgb;
                    gl_FragColor = vec4(color, a);
                }
            `,
            transparent: true,
            blending: THREE.AdditiveBlending,
            depthWrite: false
        });

        const points = new THREE.Points(geometry, material);
        scene.add(points);

        // glow pass: larger, low-opacity points for bloom-like feel
        const glowMaterial = new THREE.PointsMaterial({
            size: 16,
            map: sprite,
            color: new THREE.Color("#00f2ff"),
            transparent: true,
            opacity: 0.18,
            blending: THREE.AdditiveBlending,
            depthWrite: false
        });
        const glowPoints = new THREE.Points(geometry, glowMaterial);
        scene.add(glowPoints);

        // text/shape helpers
        let shapeTargets = [];
        let shapeActive = false;
        let shapeCenter = new THREE.Vector3(0,0,0);
        let currentText = 'I LOVE U';
        const texts = ['I LOVE U','LOVE','<3','YOU'];

        function createTextTargets(text){
            const canvas = document.createElement('canvas');
            canvas.width = 512; canvas.height = 128;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = 'black'; ctx.fillRect(0,0,canvas.width, canvas.height);
            ctx.fillStyle = 'white';
            ctx.font = 'bold 96px Inter, sans-serif';
            ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
            ctx.fillText(text, canvas.width/2, canvas.height/2);
            const img = ctx.getImageData(0,0,canvas.width,canvas.height).data;
            const pts = [];
            for(let y=0;y<canvas.height;y+=4){
                for(let x=0;x<canvas.width;x+=4){
                    const idx = (y*canvas.width + x) * 4;
                    if(img[idx] > 128){
                        const nx = (x / canvas.width - 0.5) * 8;
                        const ny = -(y / canvas.height - 0.5) * 2;
                        pts.push(new THREE.Vector3(nx, ny, 0));
                    }
                }
            }
            shapeTargets = pts;
        }
        createTextTargets(currentText);

        camera.position.z = 12; 

        // Quick WebGL availability check (helps debug black screen)
        try {
            const gl = renderer.getContext();
            if(!gl) {
                console.error('No WebGL context available');
                document.getElementById('status').textContent = 'NO WEBGL CONTEXT';
            }
        } catch(e) {
            console.error('WebGL error', e);
            document.getElementById('status').textContent = 'WEBGL ERROR';
        }

        // Debug visible mesh to ensure scene renders even if particles are invisible
        const debugMesh = new THREE.Mesh(
            new THREE.BoxGeometry(1.2,1.2,1.2),
            new THREE.MeshBasicMaterial({ color: 0xff0040 })
        );
        scene.add(debugMesh);

        // --- GESTURE ENGINE ---
        const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
        hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.6 });
        
        hands.onResults((res) => {
            document.getElementById('status').style.display = 'none';
            if (res.multiHandLandmarks && res.multiHandLandmarks[0]) {
                const h = res.multiHandLandmarks[0];
                // Distance between Thumb and Index
                const d = Math.hypot(h[4].x - h[8].x, h[4].y - h[8].y);
                const targetExp = THREE.MathUtils.clamp(
                  THREE.MathUtils.mapLinear(d, 0.02, 0.25, 0, 1.5),
                  0, 1.5
                );
                material.uniforms.uExp.value = THREE.MathUtils.lerp(material.uniforms.uExp.value, targetExp, 0.15);

                // position the shape around the hand (palm center)
                const cx = (h[9].x - 0.5) * 10;
                const cy = -(h[9].y - 0.5) * (window.innerHeight/window.innerWidth) * 10;
                shapeCenter.set(cx, cy, 0);

                // pinch to form the text shape
                if (d < 0.06) {
                    if (!shapeActive) {
                        shapeActive = true;
                        createTextTargets(currentText);
                    }
                } else {
                    shapeActive = false;
                }
            } else {
                shapeActive = false;
            }
        });

        const video = document.getElementById('webcam');
        const cam = new Camera(video, {
            onFrame: async () => { await hands.send({image: video}); },
            width: 640, height: 480
        });
        cam.start();

        // --- ANIMATION LOOP ---
        function animate(t) {
            requestAnimationFrame(animate);
            const time = t * 0.001;
            material.uniforms.uTime.value = time;

            // update physics - attraction to text targets on pinch
            const pos = geometry.attributes.position.array;
            const rnd = geometry.attributes.random.array;
            const damping = 0.92;
            const attractStrength = 0.06;
            for (let i = 0; i < count; i++) {
                const ix = i * 3;
                if (shapeActive && shapeTargets.length) {
                    const target = shapeTargets[i % shapeTargets.length];
                    const tx = target.x + shapeCenter.x;
                    const ty = target.y + shapeCenter.y;
                    const tz = target.z + shapeCenter.z;
                    let vx = (tx - pos[ix]) * attractStrength * (0.5 + rnd[i]);
                    let vy = (ty - pos[ix+1]) * attractStrength * (0.5 + rnd[i]);
                    let vz = (tz - pos[ix+2]) * attractStrength * (0.5 + rnd[i]);
                    velocities[ix] = (velocities[ix] + vx) * damping;
                    velocities[ix+1] = (velocities[ix+1] + vy) * damping;
                    velocities[ix+2] = (velocities[ix+2] + vz) * damping;
                } else {
                    velocities[ix] = velocities[ix] * damping + Math.sin(time + i) * 0.0005 * rnd[i];
                    velocities[ix+1] = velocities[ix+1] * damping + Math.cos(time * 0.5 + i) * 0.0005 * rnd[i];
                    velocities[ix+2] = velocities[ix+2] * damping + Math.sin(time * 0.3 + i) * 0.0002 * rnd[i];
                }
                pos[ix] += velocities[ix];
                pos[ix+1] += velocities[ix+1];
                pos[ix+2] += velocities[ix+2];
                // simple wrap bounds
                for (let k = 0; k < 3; k++) {
                    if (pos[ix+k] > 20) pos[ix+k] = -20;
                    if (pos[ix+k] < -20) pos[ix+k] = 20;
                }
            }
            geometry.attributes.position.needsUpdate = true;

            points.rotation.y += 0.001 + (material.uniforms.uExp.value * 0.005);
            glowPoints.rotation.y = points.rotation.y * 0.98;

            renderer.render(scene, camera);
        }
        animate();

        // UI Interactions
        document.getElementById('fs-btn').onclick = () => document.documentElement.requestFullscreen();
        document.getElementById('text-btn').onclick = () => {
            currentText = texts[(texts.indexOf(currentText) + 1) % texts.length];
            document.getElementById('text-btn').textContent = currentText;
            createTextTargets(currentText);
        };
        window.onresize = () => {
            camera.aspect = window.innerWidth/window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        };
        // stop camera & mediapipe on unload
        window.addEventListener('beforeunload', () => { try { cam.stop(); hands.close(); } catch(e){} });
    </script>
</body>
</html> 
